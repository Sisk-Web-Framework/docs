<script>
    setPageTitle("Request Handling");
    app.navPage = "docs";
</script>
<include name="component/header"></include>
<div id="appContainer">
    <section class="doc-container">
        <article class="section-content pad">
            <h1 id="request-handling">Request handling</h1>
            <p>Request handlers, also known as &quot;middlewares&quot;, are functions that run before or after a request
                is executed on the router. They can be defined per route or per router.</p>
            <p>There are two types of request handlers:</p>
            <ul>
                <li><strong>Before requests</strong>: defines that the request handler will be executed BEFORE calling
                    the router callback.
                    response with it&#39;s own response.</li>
                <li><strong>After response</strong>: defines that the request handler will be executed AFTER calling the
                    router callback.</li>
            </ul>
            <p>Both requests handlers can override the actual router callback function response. By the way, request
                handlers can be useful for validating a request, such as authentication, content, or any other
                information, such as storing information, logs, or other steps that can be performed before or after a
                response.</p>
            <p><img src="/img/requesthandlers1.png" class="center" /></p>
            <p>This way, a request handler can interrupt all this execution and return a response before finishing the
                cycle, discarding everything else in the process.</p>
            <p>Example: let&#39;s assume that a user authentication request handler does not authenticate him. It will
                prevent the request lifecycle from being continued and will hang. If this happens in the request handler
                at position two, the third and onwards will not be evaluated.</p>
            <p><img src="/img/requesthandlers2.png" class="center" /></p>
            <h2 id="creating-an-request-handler">Creating an request handler</h2>
            <p>To create a request handler, we can create a class that inherits the <a href="/spec/Sisk.Core.Routing.Handlers.IRequestHandler">IRequestHandler</a> interface, in this
                format:</p>
            <pre><code class="lang-cs">
                public class AuthenticateUserRequestHandler : IRequestHandler
                {
                    public RequestHandlerExecutionMode ExecutionMode { get; init; } = RequestHandlerExecutionMode.BeforeResponse;

                    public HttpResponse? Execute(HttpRequest request, HttpContext context)
                    {
                        if (request.Headers["Authorization"] != null)
                        {
                            // Returning null indicates that the request cycle can be continued
                            return null;
                        }
                        else
                        {
                            // Returning an HttpResponse object indicates that this response will overwrite adjacent responses.
                            return new HttpResponse(System.Net.HttpStatusCode.Unauthorized);
                        }
                    }
                }
            </code></pre>
            <p>In the above example, we indicated that if the &quot;Authorization&quot; header is present in the
                request, it should continue and the next request handler or the router callback should be called,
                whichever comes next. If it&#39;s a request handler is executed after the response by their property <a href="/spec/Sisk.Core.Routing.Handlers.IRequestHandler.ExecutionMode">ExecutionMode</a> and return
                an non-null value, it will overwrite the router&#39;s response.</p>
            <p>Whenever a Request Handler returns <code>null</code>, it indicates that the request must continue and the
                next object must be called or the cycle must end with the router&#39;s response.</p>
            <h2 id="associating-a-request-handler-with-a-single-route">Associating a request handler with a single route
            </h2>
            <p>You can define one or more request handlers for a route.</p>
            <pre><code class="lang-cs">
                mainRouter.SetRoute(RouteMethod.Get, "/", IndexPage, "", new IRequestHandler[]
                {
                    new AuthenticateUserRequestHandler(),     // before request handler
                    new ValidateJsonContentRequestHandler(),  // before request handler
                    //                                        -- method IndexPage will be executed here
                    new WriteToLogRequestHandler()            // after request handler
                });
            </code></pre>
            <p>Or creating an <a href="/spec/Sisk.Core.Routing.Route">Route</a> object:</p>
            <pre><code class="lang-cs">
                Route indexRoute = new Route(RouteMethod.Get, "/", "", IndexPage, null);
                indexRoute.RequestHandlers = new IRequestHandler[]
                {
                    new AuthenticateUserRequestHandler()
                };
                mainRouter.SetRoute(indexRoute);
            </code></pre>
            <h2 id="associating-a-request-handler-with-a-router">Associating a request handler with a router</h2>
            <p>You can define a global request handler that will runned on all routes on a router.</p>
            <pre><code class="lang-cs">mainRouter.GlobalRequestHandlers = <span class="hljs-keyword">new</span> <span class="hljs-type">IRequestHandler</span>[]
{
    <span class="hljs-keyword">new</span> <span class="hljs-type">AuthenticateUserRequestHandler</span>()
};
</code></pre>
            <h2 id="associating-a-request-handler-with-an-attribute">Associating a request handler with an attribute
            </h2>
            <p>You can define a request handler on a method attribute along with a route attribute.</p>
            <pre><code class="lang-cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span>
{
    [Route(RouteMethod.Get, <span class="hljs-string">"/"</span>)]
    [RequestHandler(<span class="hljs-keyword">typeof</span>(AuthenticateUserRequestHandler))]
    <span class="hljs-function"><span class="hljs-keyword">static</span> HttpResponse <span class="hljs-title">Index</span>(<span class="hljs-params">HttpRequest request</span>)
    </span>{
        HttpResponse res = <span class="hljs-keyword">new</span> HttpResponse();
        res.Content = <span class="hljs-keyword">new</span> StringContent(<span class="hljs-string">"Hello world!"</span>);
        <span class="hljs-keyword">return</span> res;
    }
}
</code></pre>
            <p>Note that it is necessary to pass the desired request handler type and not an object instance. That way,
                the request handler will be instantiated by the router parser. You can pass arguments in the class
                constructor with the <a href="/spec/Sisk.Core.Routing.RequestHandlerAttribute.ConstructorArguments">ConstructorArguments</a>
                property.</p>
            <p>Example:</p>
            <pre><code class="lang-cs">[RequestHandler(<span class="hljs-keyword">typeof</span>(AuthenticateUserRequestHandler), ConstructorArguments = <span class="hljs-keyword">new</span> <span class="hljs-keyword">object</span>?[] { <span class="hljs-string">"arg1"</span>, <span class="hljs-number">123</span>, ... })]
<span class="hljs-function"><span class="hljs-keyword">static</span> HttpResponse <span class="hljs-title">Index</span>(<span class="hljs-params">HttpRequest request</span>)
</span>{
    HttpResponse res = <span class="hljs-keyword">new</span> HttpResponse();
    res.Content = <span class="hljs-keyword">new</span> StringContent(<span class="hljs-string">"Hello world!"</span>);
    <span class="hljs-keyword">return</span> res;
}
</code></pre>
            <h2 id="bypassing-an-global-request-handler">Bypassing an global request handler</h2>
            <p>After defining a global request handler on a route, you can ignore this request handler on specific
                routes.</p>
            <pre><code class="lang-cs">
                var myRequestHandler = new AuthenticateUserRequestHandler();
                mainRouter.GlobalRequestHandlers = new IRequestHandler[]
                {
                    myRequestHandler
                };

                mainRouter.SetRoute(new Route(RouteMethod.Get, "/", "My route", IndexPage, null)
                {
                    BypassGlobalRequestHandlers = new IRequestHandler[]
                    {
                        myRequestHandler,                    // ok: the same instance of what is in the global request handlers
                        new AuthenticateUserRequestHandler() // wrong: will not skip the global request handler
                    }
                });
            </code></pre>
            <blockquote>
                <p>
                    <b>Note:</b>
                </p>
                <p>
                    If you're bypassing a request handler you must use the same reference of what you instanced
                    before to skip. Creating another request handler instance will not skip the global request handler
                    since it's reference will change. Remember to use the same request handler reference used in both
                    GlobalRequestHandlers and BypassGlobalRequestHandlers.
                </p>
            </blockquote>

        </article>
        <include name="component/doc-nav"></include>
    </section>
</div>