<script>
    setPageTitle("Routing");
    app.navPage = "docs";
</script>
<include name="component/header"></include>
<div id="appContainer">
    <section class="doc-container">
        <article class="section-content pad">
            <h1 id="routing">Routing</h1>
            <p>The router refers to what redirects requests to their proper places. A <a href="/spec/Sisk.Core.Routing.Router">Router</a> is
                responsible for routing <a href="/spec/Sisk.Core.Routing.Route">Route</a> to its
                responsible controllers, methods or callbacks. What the Router uses to match a route with a Route is the
                request path and its method. These two items are responsible for assigning a request to a route.</p>
            <pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, "/hey", (request) =>
{
    return request.CreateOkResponse("Hello!");
});

// alternative way using the + operator
mainRouter += new Route(RouteMethod.Get, "/", (req) =>
{
    return req.CreateOkResponse("Hello world!");
});
</code></pre>
            <p>To understand what a route is capable of doing, we need to understand what a request is capable of doing.
                An <a href="/spec/Sisk.Core.Http.HttpRequest">HttpRequest</a>
                will contain everything you need. Sisk also includes some extra features that speed up the overral
                development.</p>
            <h2 id="creating-routes-using-paths">Creating routes using paths</h2>
            <p>You can define routes using SetRoute methods.</p>
            <pre><code class="lang-cs"><span class="hljs-comment">// will match / on GET</span>
<span class="hljs-selector-tag">mainRouter</span><span class="hljs-selector-class">.SetRoute</span>(RouteMethod.Get, <span class="hljs-string">"/"</span>, callbackFunction);
</code></pre>
            <p>You can also specify parameters in the path and get them in the request. Parameters names is denoted by
                <code>&lt;</code> and <code>&gt;</code>.
            </p>
            <pre><code class="lang-cs">mainRouter.SetRoute(RouteMethod.Get, <span class="hljs-string">"/hey/&lt;name&gt;"</span>, <span class="hljs-function"><span class="hljs-params">(request)</span> =&gt;</span>
{
    <span class="hljs-built_in">string</span> name = request.Query[<span class="hljs-string">"name"</span>]!; // name will never be null <span class="hljs-keyword">in</span> this context
    <span class="hljs-keyword">return</span> request.CreateOkResponse($<span class="hljs-string">"Hello, {name}"</span>);
});

// <span class="hljs-keyword">or</span> multiple parameters
mainRouter.SetRoute(RouteMethod.Get, <span class="hljs-string">"/hey/&lt;name&gt;/surname/&lt;surname&gt;"</span>, <span class="hljs-function"><span class="hljs-params">(request)</span> =&gt;</span>
{
    <span class="hljs-built_in">string</span> name = request.Query[<span class="hljs-string">"name"</span>]!;
    <span class="hljs-built_in">string</span> surname = request.Query[<span class="hljs-string">"surname"</span>]!;
    <span class="hljs-keyword">return</span> request.CreateOkResponse($<span class="hljs-string">"Hello, {name} {surname}!"</span>);
});
</code></pre>
            <p>The HTTP request <a href="/spec/Sisk.Core.Http.HttpRequest.Query">Query</a>
                property also stores the content of an original query, but if there are parameters in the route with the
                same name as a query, it will be replaced by what is in the route. The path that is matched with an
                request URI is always the path as explained in <a href="https://www.rfc-editor.org/rfc/rfc3986#section-3.3">RFC 3986</a>.</p>
            <blockquote>
                <p>Paths have their trailing <code>/</code> ignored in both request and route path, that is, if you try
                    to access a route defined as <code>/index/page</code> you&#39;ll be able to access using
                    <code>/index/page/</code> too.
                </p>
            </blockquote>
            <h2 id="creating-routes-using-class-instances">Creating routes using class instances</h2>
            <p>You can also define routes dynamically using reflection with the attribute <a href="/spec/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a>.
                This way, the instance of a class in which its methods implement this attribute will have their routes
                defined in the target router.</p>
            <p>Methods marked with the route attribute must be static.</p>
            <pre><code class="lang-cs">
                public class MyController
                {
                    // will be reached as an instance form
                    [Route(RouteMethod.Get, "/")]
                    HttpResponse Index(HttpRequest request)
                    {
                        HttpResponse res = new HttpResponse();
                        res.Content = new StringContent("Index!");
                        return res;
                    }

                    // static methods only be reached when setting the object type
                    [Route(RouteMethod.Get, "/hello")]
                    static HttpResponse Hello(HttpRequest request)
                    {
                        HttpResponse res = new HttpResponse();
                        res.Content = new StringContent("Hello world!");
                        return res;
                    }
                }
            </code></pre>
            <p>
                Then you can define the routes of the MyController instance:
            </p>
            <pre><code class="lang-cs">
                var myController = new MyController();
                mainRouter.SetObject(myController);
            </code></pre>
            <p>
                Alternatively, you can define your members statically,
                without an instance, by passing the class's type as a parameter:
            </p>
            <pre><code class="lang-cs">
                mainRouter.SetObject(typeof(MyController));
            </code></pre>
            <h2 id="regex-routes">Regex routes</h2>
            <p>Instead of using the default HTTP path matching methods, you can mark a route to be interpreted with
                Regex.</p>
            <pre><code class="lang-cs">Route indexRoute = <span class="hljs-keyword">new</span> <span class="hljs-type">Route</span>(RouteMethod.Get, @<span class="hljs-string">"\/[a-z]+\/"</span>, <span class="hljs-string">"My route"</span>, IndexPage, <span class="hljs-literal">null</span>);
indexRoute.UseRegex = <span class="hljs-literal">true</span>;
mainRouter.SetRoute(indexRoute);
</code></pre>
            <h2 id="any-method-routes">Any method routes</h2>
            <p>You can define a route to be matched only by its path and skip the HTTP method. This can be useful for
                you to do method validation inside the route callback.</p>
            <pre><code class="lang-cs"><span class="hljs-comment">// will match / on any HTTP method</span>
mainRouter.SetRoute(RouteMethod.<span class="hljs-keyword">Any</span>, <span class="hljs-string">"/"</span>, callbackFunction);
</code></pre>
            <h2 id="ignore-case-route-matching">Ignore case route matching</h2>
            <p>By default, the interpretation of routes with requests are case-sensitive. To make it ignore case, enable
                this option:</p>
            <pre><code class="lang-cs">
                mainRouter.MatchRoutesIgnoreCase = true;
            </code></pre>
            <p>This will also enable the option <code>RegexOptions.IgnoreCase</code> for routes where it&#39;s
                regex-matching.</p>
            <h2 id="not-found-404-callback-handler">Not Found (404) callback handler</h2>
            <p>You can create a custom callback for when a request doesn&#39;t match any known routes.</p>
            <pre><code class="lang-cs">mainRouter.NotFoundErrorHandler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpResponse(<span class="hljs-number">404</span>)
    {
        Content = <span class="hljs-keyword">new</span> StringContent(<span class="hljs-string">"Couldn't find your route!"</span>)
    };
};
</code></pre>
            <h2 id="method-not-allowed-405-callback-handler">Method not allowed (405) callback handler</h2>
            <p>You can also create a custom callback for when a request matches it&#39;s path, but doens&#39;t match the
                method.</p>
            <pre><code class="lang-cs">mainRouter.MethodNotAllowedErrorHandler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpResponse(<span class="hljs-number">405</span>)
    {
        Content = <span class="hljs-keyword">new</span> StringContent($<span class="hljs-string">"This request is only GET request!"</span>)
    };
};
</code></pre>
            <h2 id="internal-error-handler">Internal error handler</h2>
            <p>Route callbacks can throw errors during server execution. If not handled correctly, the overall
                functioning of the HTTP server can be terminated. The router has a callback for when a route callback
                fails and prevents service interruption.</p>
            <pre><code class="lang-cs">mainRouter.CallbackErrorHandler = <span class="hljs-function"><span class="hljs-params">(ex, req)</span> =&gt;</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpResponse(<span class="hljs-number">500</span>)
    {
        Content = <span class="hljs-keyword">new</span> StringContent($<span class="hljs-string">"Error: {ex.Message}"</span>)
    };
};
</code></pre>

        </article>
        <include name="component/doc-nav"></include>
    </section>
</div>