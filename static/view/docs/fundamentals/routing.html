<script>
    setPageTitle("Routing");
    app.navPage = "docs";
</script>
<include name="component/header"></include>
<div id="appContainer">
    <section class="doc-container">
        <article class="section-content pad">
            <h1 id="routing">Routing</h1>
            <p>The router refers to what redirects requests to their proper places. A <a href="/spec/Sisk.Core.Routing.Router">Router</a> is
                responsible for routing <a href="/spec/Sisk.Core.Routing.Route">Route</a> to its
                responsible controllers, methods or callbacks. What the Router uses to match a route with a Route is the
                request path and its method. These two items are responsible for assigning a request to a route.</p>
            <pre><code class="lang-cs">
mainRouter.SetRoute(RouteMethod.Get, "/hey", (request) =>
{
    return new HttpResponse() { Content = new StringContent("Hello!") };
});

// alternative way using the + operator
mainRouter += new Route(RouteMethod.Get, "/", (req) =>
{
    return new HttpResponse() 
    { 
        Content = new StringContent("...world"), 
        Status = HttpStatusCode.Ok 
    };
});
</code></pre>
            <p>To understand what a route is capable of doing, we need to understand what a request is capable of doing.
                An <a href="/spec/Sisk.Core.Http.HttpRequest">HttpRequest</a>
                will contain everything you need. Sisk also includes some extra features that speed up the overral
                development.</p>
            <h2 id="creating-routes-using-paths">Creating routes using paths</h2>
            <p>You can define routes using SetRoute methods.</p>
            <pre><code class="lang-cs">
                <xmp>
                    mainRouter.SetRoute(RouteMethod.Get, "/hey/<name>", (request) =>
                    {
                        string name = request.Query["name"]!; // name will never be null in this context
                        return request.CreateOkResponse($"Hello, {name}");
                    });
                    
                    // or multiple parameters
                    mainRouter.SetRoute(RouteMethod.Get, "/hey/<name>/surname/<surname>", (request) =>
                    {
                        string name = request.Query["name"]!;
                        string surname = request.Query["surname"]!;
                        return request.CreateOkResponse($"Hello, {name} {surname}!");
                    });
                </xmp>
            </code></pre>
            <p>The HTTP request <a href="/spec/Sisk.Core.Http.HttpRequest.Query">Query</a>
                property also stores the content of an original query, but if there are parameters in the route with the
                same name as a query, it will be replaced by what is in the route. The path that is matched with an
                request URI is always the path as explained in <a href="https://www.rfc-editor.org/rfc/rfc3986#section-3.3">RFC 3986</a>.</p>
            <blockquote>
                <p>
                    <b>Note:</b>
                </p>
                <p>
                    Paths have their trailing <code>/</code> ignored in both request and route path, that is, if you try
                    to access a route defined as <code>/index/page</code> you&#39;ll be able to access using
                    <code>/index/page/</code> too.
                </p>
                <p>
                    You can also force URLs to terminate with <code>/</code> enabling the
                    <a href="/spec/Sisk.Core.Http.HttpServerFlags.ForceTrailingSlash">ForceTrailingSlash</a> flag.
                </p>
            </blockquote>
            <h2 id="creating-routes-using-class-instances">Creating routes using class instances</h2>
            <p>You can also define routes dynamically using reflection with the attribute <a href="/spec/Sisk.Core.Routing.RouteAttribute">RouteAttribute</a>.
                This way, the instance of a class in which its methods implement this attribute will have their routes
                defined in the target router.</p>
            <p>Methods marked with the route attribute must be static.</p>
            <pre><code class="lang-cs">
                public class MyController
                {
                    // will be reached as an instance form
                    [Route(RouteMethod.Get, "/")]
                    HttpResponse Index(HttpRequest request)
                    {
                        HttpResponse res = new HttpResponse();
                        res.Content = new StringContent("Index!");
                        return res;
                    }

                    // static methods only be reached when setting the object type
                    [Route(RouteMethod.Get, "/hello")]
                    static HttpResponse Hello(HttpRequest request)
                    {
                        HttpResponse res = new HttpResponse();
                        res.Content = new StringContent("Hello world!");
                        return res;
                    }
                }
            </code></pre>
            <p>
                Then you can define the routes of the MyController instance:
            </p>
            <pre><code class="lang-cs">
                var myController = new MyController();
                mainRouter.SetObject(myController);
            </code></pre>
            <p>
                Alternatively, you can define your members statically,
                without an instance, by passing the class's type as a parameter:
            </p>
            <pre><code class="lang-cs">
                mainRouter.SetObject(typeof(MyController));
            </code></pre>
            <h2 id="regex-routes">Regex routes</h2>
            <p>Instead of using the default HTTP path matching methods, you can mark a route to be interpreted with
                Regex.</p>
            <pre><code class="lang-cs">Route indexRoute = <span class="hljs-keyword">new</span> <span class="hljs-type">Route</span>(RouteMethod.Get, @<span class="hljs-string">"\/[a-z]+\/"</span>, <span class="hljs-string">"My route"</span>, IndexPage, <span class="hljs-literal">null</span>);
indexRoute.UseRegex = <span class="hljs-literal">true</span>;
mainRouter.SetRoute(indexRoute);
</code></pre>
            <h2 id="any-method-routes">Any method routes</h2>
            <p>You can define a route to be matched only by its path and skip the HTTP method. This can be useful for
                you to do method validation inside the route callback.</p>
            <pre><code class="lang-cs"><span class="hljs-comment">// will match / on any HTTP method</span>
mainRouter.SetRoute(RouteMethod.<span class="hljs-keyword">Any</span>, <span class="hljs-string">"/"</span>, callbackFunction);
</code></pre>
            <h2 id="ignore-case-route-matching">Ignore case route matching</h2>
            <p>By default, the interpretation of routes with requests are case-sensitive. To make it ignore case, enable
                this option:</p>
            <pre><code class="lang-cs">
                mainRouter.MatchRoutesIgnoreCase = true;
            </code></pre>
            <p>This will also enable the option <code>RegexOptions.IgnoreCase</code> for routes where it&#39;s
                regex-matching.</p>
            <h2 id="not-found-404-callback-handler">Not Found (404) callback handler</h2>
            <p>You can create a custom callback for when a request doesn&#39;t match any known routes.</p>
            <pre><code class="lang-cs">
                <xmp>
                    mainRouter.NotFoundErrorHandler = () =>
                    {
                        return new HttpResponse(404)
                        {
                            // Since v0.14
                            Content = new HtmlContent("<h1>Not found</h1>")
                            // older versions
                            Content = new StringContent("<h1>Not found</h1>", Encoding.UTF8, "text/html")
                        };
                    };
                </xmp>
            </code></pre>
            <h2 id="method-not-allowed-405-callback-handler">Method not allowed (405) callback handler</h2>
            <p>You can also create a custom callback for when a request matches it&#39;s path, but doens&#39;t match the
                method.</p>
            <pre><code class="lang-cs">mainRouter.MethodNotAllowedErrorHandler = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpResponse(<span class="hljs-number">405</span>)
    {
        Content = <span class="hljs-keyword">new</span> StringContent($<span class="hljs-string">"This request is only GET request!"</span>)
    };
};
</code></pre>
            <h2 id="internal-error-handler">Internal error handler</h2>
            <p>Route callbacks can throw errors during server execution. If not handled correctly, the overall
                functioning of the HTTP server can be terminated. The router has a callback for when a route callback
                fails and prevents service interruption.</p>
            <pre><code class="lang-cs">mainRouter.CallbackErrorHandler = <span class="hljs-function"><span class="hljs-params">(ex, req)</span> =&gt;</span>
{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HttpResponse(<span class="hljs-number">500</span>)
    {
        Content = <span class="hljs-keyword">new</span> StringContent($<span class="hljs-string">"Error: {ex.Message}"</span>)
    };
};
</code></pre>

        </article>
        <include name="component/doc-nav"></include>
    </section>
</div>