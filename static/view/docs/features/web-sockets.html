<script>
    setPageTitle("Logging");
    app.navPage = "docs";
</script>
<include name="component/header"></include>
<div id="appContainer">
    <section class="doc-container">
        <article class="section-content pad">
            <h1>Web Sockets</h1>
            <p>
                Sisk supports web sockets as well, such as receiving and sending messages to their client.
            </p>
            <p>
                This feature works fine in most browsers, but in Sisk it is still experimental. Please,
                if you find any bugs, report it on github.
            </p>
            <section>
                <h2 id="getting-an-ws-connection">
                    Accepting and receiving messages asynchronously
                </h2>
                <p>
                    The example below shows how websocket works in practice, with an example of
                    opening a connection, receiving a message and displaying it in the console.
                </p>
                <p>
                    All messages received by WebSocket are received in bytes, so you will
                    have to decode them upon receipt.
                </p>
                <p>
                    By default, messages are fragmented into chunks and the last piece is sent as the final packet
                    of the message. You can configure the packet size with the <a href="/spec/Sisk.Core.Http.HttpServerFlags.WebSocketBufferSize">WebSocketBufferSize</a>
                    flag. This buffering is the same for sending and receiving messages.
                </p>
                <pre><code class="language-cs">static ListeningHost BuildLhA()
{
    Router r = new Router();

    r += new Route(RouteMethod.Get, "/", (req) =>
    {
        var ws = req.GetWebSocket();

        ws.OnReceive += (sender, msg) =>
        {
            string msgText = Encoding.UTF8.GetString(msg.MessageBytes);
            Console.WriteLine("Received message: " + msgText);

            // gets the HttpWebSocket context which received the message
            HttpWebSocket senderWebSocket = (HttpWebSocket)sender!;
            senderWebSocket.Send("Response!");
        };

        ws.WaitForClose();

        return ws.Close();
    });

    return new ListeningHost("localhost", 5551, r);
}</code></pre>
            </section>
            <section>
                <h2 id="getting-an-ws-connection-sync">
                    Accepting and receiving messages synchronously
                </h2>
                <p>
                    The example below contains a way for you to use a synchronous websocket,
                    without an asynchronous context, where you receive the messages,
                    deal with them, and finish using the socket.
                </p>
                <pre><code class="language-cs">static ListeningHost BuildLhA()
{
    Router r = new Router();

    r += new Route(RouteMethod.Get, "/connect", (req) =>
    {
        var ws = req.GetWebSocket();
        WebSocketMessage? msg;

    askName:
        ws.Send("What is your name?");
        msg = ws.WaitNext();

        string? name = msg?.GetString();

        if (string.IsNullOrEmpty(name))
        {
            ws.Send("Please, insert your name!");
            goto askName;
        }

    askAge:
        ws.Send("And your age?");
        msg = ws.WaitNext();

        if (!Int32.TryParse(msg?.GetString(), out int age))
        {
            ws.Send("Please, insert an valid number");
            goto askAge;
        }

        ws.Send($"You're {name}, and you are {age} old.");

        return ws.Close();
    });

    return new ListeningHost("localhost", 5551, r);
}</code></pre>
            </section>
            <section>
                <h2 id="sending-messages">
                    Sending messages
                </h2>
                <p>
                    The Send method has three overloads, which allow you to send text, a byte array, or a byte span. All of them
                    is chunked if the server's <a href="/spec/Sisk.Core.Http.HttpServerFlags.WebSocketBufferSize">WebSocketBufferSize</a> flag is
                    greater than the total payload size.
                </p>
                <pre><code class="language-cs">static ListeningHost BuildLhA()
{
    Router r = new Router();

    r += new Route(RouteMethod.Get, "/", (req) =>
    {
        var ws = req.GetWebSocket();

        byte[] myByteArrayContent = ...;

        ws.Send("Hello, world");     // will be encoded as an UTF-8 byte array
        ws.Send(myByteArrayContent);

        return ws.Close();
    });

    return new ListeningHost("localhost", 5551, r);
}</code></pre>
            </section>
            <section>
                <h2 id="closing-connection">
                    Waiting for websocket close
                </h2>
                <p>
                    The method <a href="/spec/Sisk.Core.Http.HttpWebSocket.WaitForClose()">WaitForClose()</a> blocks the current call
                    stack until the connection is terminated by either the client or the server.
                </p>
                <p>
                    With this, the execution of the callback of the request will be blocked until the client or the server disconnects.
                </p>
                <p>
                    You can also manually close the connection with the <a href="/spec/Sisk.Core.Http.HttpWebSocket.Close()">Close()</a> method.
                    This method returns an empty <a href="/spec/Sisk.Core.Http.HttpResponse">HttpResponse</a> object, which is not sent to the client,
                    but works as a return from the function where the HTTP request was received.
                </p>
                <pre><code class="language-cs">static ListeningHost BuildLhA()
{
    Router r = new Router();

    r += new Route(RouteMethod.Get, "/", (req) =>
    {
        var ws = req.GetWebSocket();

        // wait for client close connection
        ws.WaitForClose();

        return ws.Close();
    });

    return new ListeningHost("localhost", 5551, r);
}</code></pre>
            </section>
        </article>
        <include name="component/doc-nav"></include>
    </section>
</div>